<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Interactive demo of WasmTS - Spatial operations and computational geometry for WebAssembly. Try geometry operations, spatial indexing, and 3D/4D coordinates in your browser.">
    <title>WasmTS - Spatial Operations for WebAssembly</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/editor/editor.main.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .about {
            background-color: #f0f8ff;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
        }
        .success {
            color: green;
        }
        .error {
            color: red;
        }
        #replInput {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #replOutput {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            background: #f4f4f4;
            padding: 15px;
            border-radius: 3px;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .repl-line {
            margin: 5px 0;
        }
        .repl-input {
            color: #0066cc;
        }
        .repl-output {
            color: #000;
        }
        .repl-error {
            color: red;
        }
        .repl-hint {
            color: #666;
            font-style: italic;
            margin-top: 10px;
        }
        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }
        select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            background: white;
            cursor: pointer;
            min-width: 300px;
        }
        select:disabled {
            background: #f5f5f5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <h1>WasmTS Browser Demo</h1>

    <section class="about">
        <h2>About</h2>
        <p>Browser-based demonstration of <strong>WasmTS</strong>, a WebAssembly port of JTS Topology Suite using GraalVM Native Image.</p>

        <h3>Key Features</h3>
        <ul>
            <li>Geometry types: Point, LineString, Polygon, Multi*, GeometryCollection</li>
            <li>Operations: buffer, union, intersection, difference, convexHull, simplify</li>
            <li>Spatial predicates: contains, intersects, touches, crosses, within, overlaps, covers, equalsTopo</li>
            <li>Geometry transformations: copy, reverse, normalize, getBoundary, getCentroid</li>
            <li>Coordinate support: 2D, 3D (XYZ), and 4D (XYZM)</li>
            <li>STRtree spatial indexing for efficient queries</li>
            <li>PreparedGeometry for optimized repeated predicates</li>
            <li>Advanced operations: LineMerger, CascadedPolygonUnion, OffsetCurveBuilder</li>
            <li>WKT, WKB, and GeoJSON input/output</li>
        </ul>

        <h3>Implementation</h3>
        <ul>
            <li>JTS Topology Suite 1.20.0 compiled to WebAssembly using GraalVM Native Image (26 EA) with web-image backend</li>
            <li>Direct Java-JavaScript bindings via GraalVM <code>@JS</code> annotations</li>
            <li>Automatic memory management via JavaScript GC</li>
            <li>Runs entirely client-side with no server communication</li>
        </ul>

        <p><strong>Links:</strong> <a href="https://github.com/willcohen/wasmts">GitHub</a> | <a href="https://github.com/locationtech/jts">JTS Repository</a> | <a href="https://github.com/oracle/graal/tree/master/web-image">GraalVM web-image</a></p>
    </section>

    <section>
        <h2>Load Status</h2>
        <div id="loadStatus" class="loading">Loading WASM module...</div>
    </section>

    <section>
        <h2>Interactive REPL</h2>
        <p>Enter JavaScript code using the <code>wasmts</code> API. Results will be displayed below.</p>
        <div id="replInput"></div>
        <div class="button-row">
            <button id="replRun" disabled>Run (Ctrl+Enter)</button>
            <button id="replClear" disabled>Clear Output</button>
            <select id="exampleSelect" disabled>
                <option value="">Load Example...</option>
                <option value="geometry">Geometry Methods (Operations, Predicates, Transformations)</option>
                <option value="buffer">Buffering (Simple and Advanced)</option>
                <option value="strtree">STRtree Spatial Index</option>
                <option value="prepared">PreparedGeometry (Optimized Predicates)</option>
                <option value="rectangles">Minimum Bounding Rectangles & Circles</option>
                <option value="offsetcurve">Offset Curves</option>
                <option value="linemerger">LineMerger</option>
                <option value="cascadedunion">CascadedPolygonUnion</option>
                <option value="3d">3D Geometries (XYZ)</option>
                <option value="4d">4D Geometries (XYZM)</option>
                <option value="io">WKT/WKB I/O</option>
                <option value="geojson">GeoJSON I/O</option>
                <option value="polyaccessors">Polygon Accessors (Rings & Holes)</option>
                <option value="distance">Distance Operations (nearest points)</option>
                <option value="factory">Geometry Factory (create from coords)</option>
            </select>
        </div>
        <div id="replOutput"></div>
    </div>

    <!-- Load Monaco Editor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>

    <!-- Load the WASM module as a regular script -->
    <!-- Using <script src> ensures document.currentScript points to wasmts.js -->
    <script src="https://cdn.jsdelivr.net/npm/@wcohen/wasmts@0.1.0-alpha2/dist/wasmts.js"></script>
    <!-- For local development, use: -->
    <!-- <script src="../dist/wasmts.js"></script> -->

    <script>
        // Configure Monaco Editor
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' }});

        let monacoEditor = null;

        require(['vs/editor/editor.main'], function() {
            // Create Monaco Editor
            monacoEditor = monaco.editor.create(document.getElementById('replInput'), {
                value: `// Try some commands:\nconst point = wasmts.geom.createPoint(5, 10);\npoint.buffer(5).getArea()`,
                language: 'javascript',
                theme: 'vs-dark',
                minimap: { enabled: false },
                automaticLayout: true,
                fontSize: 14,
                lineNumbers: 'on',
                scrollBeyondLastLine: false,
                wordWrap: 'on'
            });

            // Add Ctrl+Enter to run
            monacoEditor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, function() {
                runREPL();
            });

            // Setup autocomplete for wasmts API
            monaco.languages.registerCompletionItemProvider('javascript', {
                provideCompletionItems: function(model, position) {
                    const suggestions = [
                        // wasmts namespace
                        { label: 'wasmts', kind: monaco.languages.CompletionItemKind.Module, insertText: 'wasmts', documentation: 'WasmTS root namespace' },
                        { label: 'wasmts.geom', kind: monaco.languages.CompletionItemKind.Module, insertText: 'wasmts.geom', documentation: 'Geometry operations' },
                        { label: 'wasmts.io', kind: monaco.languages.CompletionItemKind.Module, insertText: 'wasmts.io', documentation: 'I/O operations' },
                        { label: 'wasmts.index.strtree', kind: monaco.languages.CompletionItemKind.Module, insertText: 'wasmts.index.strtree', documentation: 'Spatial indexing' },

                        // Geometry creation
                        { label: 'createPoint', kind: monaco.languages.CompletionItemKind.Function, insertText: 'createPoint(${1:x}, ${2:y})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet },
                        { label: 'createLineString', kind: monaco.languages.CompletionItemKind.Function, insertText: 'createLineString(${1:coords})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet },
                        { label: 'createPolygon', kind: monaco.languages.CompletionItemKind.Function, insertText: 'createPolygon(${1:shell}, ${2:holes})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet },
                        { label: 'GeometryFactory', kind: monaco.languages.CompletionItemKind.Function, insertText: 'GeometryFactory()', documentation: 'Create geometry factory' },

                        // Operations
                        { label: 'buffer', kind: monaco.languages.CompletionItemKind.Method, insertText: 'buffer(${1:distance})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet },
                        { label: 'union', kind: monaco.languages.CompletionItemKind.Method, insertText: 'union(${1:other})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet },
                        { label: 'intersection', kind: monaco.languages.CompletionItemKind.Method, insertText: 'intersection(${1:other})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet },
                        { label: 'contains', kind: monaco.languages.CompletionItemKind.Method, insertText: 'contains(${1:other})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet },
                        { label: 'getArea', kind: monaco.languages.CompletionItemKind.Method, insertText: 'getArea()', documentation: 'Get area of geometry' },

                        // I/O
                        { label: 'readWKT', kind: monaco.languages.CompletionItemKind.Function, insertText: 'readWKT(${1:wkt})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, documentation: 'Read WKT (Well-Known Text)' },
                        { label: 'writeWKT', kind: monaco.languages.CompletionItemKind.Function, insertText: 'writeWKT(${1:geom})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, documentation: 'Write WKT (Well-Known Text)' },
                        { label: 'readWKB', kind: monaco.languages.CompletionItemKind.Function, insertText: 'readWKB(${1:bytes})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, documentation: 'Read WKB (Well-Known Binary)' },
                        { label: 'writeWKB', kind: monaco.languages.CompletionItemKind.Function, insertText: 'writeWKB(${1:geom})', insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, documentation: 'Write WKB (Well-Known Binary)' },
                    ];
                    return { suggestions: suggestions };
                }
            });
        });
    </script>

    <script>
        // Wait for WASM to initialize after the script loads
        console.log('Waiting for WASM initialization...');
        waitForWasmTS();

        function waitForWasmTS() {
            const maxAttempts = 50; // 5 seconds max
            let attempts = 0;

            const checkInterval = setInterval(() => {
                attempts++;

                if (typeof wasmts !== 'undefined' && wasmts.geom) {
                    clearInterval(checkInterval);
                    console.log('WasmTS initialized!');
                    checkAPI();
                } else if (attempts >= maxAttempts) {
                    clearInterval(checkInterval);
                    const status = document.getElementById('loadStatus');
                    status.className = 'test-result error';
                    status.innerHTML = '✗ Timeout waiting for WasmTS initialization<br>' +
                                      'Check browser console for errors';
                }
            }, 100);
        }

        function checkAPI() {
            const status = document.getElementById('loadStatus');

            // Check if wasmts namespace exists
            if (typeof wasmts !== 'undefined') {
                status.className = 'test-result success';
                status.textContent = '✓ WasmTS loaded successfully';

                // Enable test buttons and dropdown
                document.querySelectorAll('button').forEach(btn => btn.disabled = false);
                document.querySelectorAll('select').forEach(sel => sel.disabled = false);
            } else {
                status.className = 'test-result error';
                status.textContent = '✗ wasmts namespace not found - API may not be exported correctly';
            }
        }


        // Example code templates
        const examples = {
            geometry: `// Comprehensive Geometry Methods Demo
// Operations, Predicates, Transformations, Properties, and Validation

// === BASIC OPERATIONS ===
console.log('=== Basic Operations ===');

// Create geometries
const circle1 = wasmts.geom.createPoint(0, 0).buffer(10);
const circle2 = wasmts.geom.createPoint(15, 0).buffer(10);

// Union - combines geometries
const union = circle1.union(circle2);
console.log('Union area:', union.getArea().toFixed(2));

// Intersection - overlapping region
const intersection = circle1.intersection(circle2);
console.log('Intersection area:', intersection.getArea().toFixed(2));

// Difference - subtract one from another
const difference = circle1.difference(circle2);
console.log('Difference area:', difference.getArea().toFixed(2));

// Symmetric difference - non-overlapping parts
const symDiff = circle1.symDifference(circle2);
console.log('Symmetric difference area:', symDiff.getArea().toFixed(2));

// Convex hull
const poly = wasmts.io.WKTReader.read('POLYGON ((0 0, 10 2, 12 10, 2 12, 0 0))');
const hull = poly.convexHull();
console.log('Convex hull area:', hull.getArea().toFixed(2));

// === SPATIAL PREDICATES ===
console.log('\\n=== Spatial Predicates ===');

const container = wasmts.io.WKTReader.read('POLYGON ((0 0, 20 0, 20 20, 0 20, 0 0))');
const small = wasmts.io.WKTReader.read('POLYGON ((5 5, 15 5, 15 15, 5 15, 5 5))');

console.log('container.contains(small):', container.contains(small));
console.log('small.within(container):', small.within(container));
console.log('container.covers(small):', container.covers(small));
console.log('small.coveredBy(container):', small.coveredBy(container));
console.log('container.intersects(small):', container.intersects(small));
console.log('container.disjoint(small):', container.disjoint(small));

// Topological equality
const poly1 = wasmts.io.WKTReader.read('POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))');
const poly2 = wasmts.io.WKTReader.read('POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))');
console.log('poly1.equalsTopo(poly2):', poly1.equalsTopo(poly2));

// === GEOMETRY TRANSFORMATIONS ===
console.log('\\n=== Transformations ===');

// Copy
const polyCopy = poly1.copy();
console.log('Copy equalsTopo:', polyCopy.equalsTopo(poly1));

// Reverse coordinate order
const line = wasmts.io.WKTReader.read('LINESTRING (0 0, 5 5, 10 0)');
const reversed = line.reverse();
console.log('Reversed:', wasmts.io.WKTWriter.write(reversed).substring(0, 40));

// Normalize to canonical form
const normalized = poly1.normalize();
console.log('Normalized');

// Boundary
const boundary = poly1.getBoundary();
console.log('Boundary type:', boundary.type);

// Centroid
const centroid = poly1.getCentroid();
console.log('Centroid:', wasmts.io.WKTWriter.write(centroid));

// === GEOMETRY PROPERTIES ===
console.log('\\n=== Properties ===');

// Envelope (bounding box)
const envelope = poly1.getEnvelope();
console.log('Envelope:', wasmts.io.WKTWriter.write(envelope));

// Interior point (guaranteed inside)
const interior = poly1.getInteriorPoint();
console.log('Interior point inside:', poly1.contains(interior));

// Measurements
console.log('Area:', poly1.getArea());
console.log('Length:', line.getLength().toFixed(2));
console.log('Distance:', poly1.distance(small).toFixed(2));
console.log('Num points:', poly1.getNumPoints());

// Geometry type inspection
console.log('\\nGeometry types:');
const testPoint = wasmts.geom.createPoint(5, 10);
console.log('point type:', testPoint.getGeometryType());
console.log('line type:', line.getGeometryType());
console.log('poly1 type:', poly1.getGeometryType());

// === VALIDATION ===
console.log('\\n=== Validation ===');

console.log('poly1.isEmpty():', poly1.isEmpty());
console.log('poly1.isValid():', poly1.isValid());
console.log('poly1.isSimple():', poly1.isSimple());
console.log('poly1.isRectangle():', poly1.isRectangle());

const selfIntersecting = wasmts.io.WKTReader.read('LINESTRING (0 0, 10 10, 10 0, 0 10)');
console.log('Self-intersecting line.isSimple():', selfIntersecting.isSimple());

// === USER DATA ===
console.log('\\n=== User Data ===');
poly1.setUserData({ id: 123, name: 'Test' });
console.log('User data:', poly1.getUserData());

union`,

            buffer: `// Buffering - Simple and Advanced
// Create zones, offsets, and parallel curves

console.log('=== Simple Buffering ===');

// Basic point buffer
const point = wasmts.geom.createPoint(0, 0);
const buffered = point.buffer(10);
console.log('Buffer area:', buffered.getArea().toFixed(2), '(should be π*r² ≈ 314.16)');

// Line buffer
const line = wasmts.io.WKTReader.read('LINESTRING (0 0, 10 0)');
const lineBuffer = line.buffer(2);
console.log('Line buffer area:', lineBuffer.getArea().toFixed(2));

// Negative buffer (erosion)
const poly = wasmts.io.WKTReader.read('POLYGON ((0 0, 20 0, 20 20, 0 20, 0 0))');
const eroded = poly.buffer(-2);
console.log('Original area:', poly.getArea());
console.log('Eroded area:', eroded.getArea().toFixed(2));

console.log('\\n=== Advanced Buffering ===');

// Buffer parameter constants
const CAP_ROUND = 1, CAP_FLAT = 2, CAP_SQUARE = 3;
const JOIN_ROUND = 1, JOIN_MITRE = 2, JOIN_BEVEL = 3;

// Different cap styles
const roundCap = line.buffer(2, CAP_ROUND, JOIN_ROUND, 5.0);
const flatCap = line.buffer(2, CAP_FLAT, JOIN_ROUND, 5.0);
const squareCap = line.buffer(2, CAP_SQUARE, JOIN_ROUND, 5.0);

console.log('Round cap area:', roundCap.getArea().toFixed(2));
console.log('Flat cap area:', flatCap.getArea().toFixed(2));
console.log('Square cap area:', squareCap.getArea().toFixed(2));

// Different join styles on sharp corners
const sharpPoly = wasmts.io.WKTReader.read('POLYGON ((0 0, 10 0, 10 1, 5 1, 5 10, 0 10, 0 0))');
const mitreJoin = sharpPoly.buffer(0.5, CAP_ROUND, JOIN_MITRE, 10.0);
const bevelJoin = sharpPoly.buffer(0.5, CAP_ROUND, JOIN_BEVEL, 5.0);
const roundJoin = sharpPoly.buffer(0.5, CAP_ROUND, JOIN_ROUND, 5.0);

console.log('Mitre join area:', mitreJoin.getArea().toFixed(2));
console.log('Bevel join area:', bevelJoin.getArea().toFixed(2));
console.log('Round join area:', roundJoin.getArea().toFixed(2));

buffered`,

            strtree: `// STRtree Spatial Indexing
// Efficient spatial queries using R-tree index
const startTime = performance.now();

// Create STRtree
const index = wasmts.index.strtree.STRtree.create();
console.log('STRtree created');

// Insert 100 random polygons
const geometries = [];
for (let i = 0; i < 100; i++) {
    const x = Math.random() * 1000;
    const y = Math.random() * 1000;
    const poly = wasmts.io.WKTReader.read(
        \`POLYGON ((\${x} \${y}, \${x+10} \${y}, \${x+10} \${y+10}, \${x} \${y+10}, \${x} \${y}))\`
    );
    const envelope = poly.getEnvelopeInternal();
    wasmts.index.strtree.STRtree.insert(index, envelope, {id: i, geom: poly});
    geometries.push({id: i, poly, envelope});
}
console.log('Inserted 100 geometries');

// Query with search envelope
const searchEnv = wasmts.geom.createEnvelope(0, 100, 0, 100);
const results = wasmts.index.strtree.STRtree.query(index, searchEnv);

const indexTime = performance.now() - startTime;
console.log(\`STRtree query found \${results.length} results in \${indexTime.toFixed(2)}ms\`);

\`Found \${results.length} geometries in \${indexTime.toFixed(2)}ms\``,

            prepared: `// PreparedGeometry - Optimized for repeated predicates
// Create a complex polygon
const polygon = wasmts.io.WKTReader.read('POLYGON ((0 0, 100 0, 100 100, 0 100, 0 0), (20 20, 40 20, 40 40, 20 40, 20 20))');
console.log('Created polygon with hole, area:', polygon.getArea());

// Prepare the geometry for repeated containment tests
const prepared = wasmts.geom.prep.PreparedGeometryFactory.prepare(polygon);
console.log('PreparedGeometry created\\n');

// Test multiple points against the prepared geometry
const testPoints = [
    { x: 50, y: 50, desc: 'center of polygon' },
    { x: 30, y: 30, desc: 'inside hole' },
    { x: 0, y: 0, desc: 'on boundary' },
    { x: 150, y: 150, desc: 'outside' },
    { x: 10, y: 10, desc: 'inside (near edge)' }
];

console.log('Testing containsProperly on multiple points:');
for (const {x, y, desc} of testPoints) {
    const point = wasmts.geom.createPoint(x, y);
    const result = wasmts.geom.prep.PreparedGeometry.containsProperly(prepared, point);
    console.log(\`  (\${x}, \${y}) - \${desc}: \${result}\`);
}

// Test coveredBy with a small polygon
const smallPoly = wasmts.io.WKTReader.read('POLYGON ((5 5, 15 5, 15 15, 5 15, 5 5))');
const isCovered = wasmts.geom.prep.PreparedGeometry.coveredBy(prepared, smallPoly);
console.log('\\nSmall polygon covered by big polygon:', isCovered);

// Extract original geometry
const original = wasmts.geom.prep.PreparedGeometry.getGeometry(prepared);
console.log('\\nExtracted original geometry, area:', original.getArea());

'PreparedGeometry demo complete'`,

            rectangles: `// Minimum Bounding Rectangles & Circles
// Create an irregular polygon
const polygon = wasmts.io.WKTReader.read('POLYGON ((0 0, 10 2, 12 10, 2 12, 0 0))');
console.log('Created irregular polygon');
console.log('  Area:', polygon.getArea().toFixed(2));
console.log('');

// Find minimum-width bounding rectangle (based on minimum diameter)
const minDiamRect = wasmts.algorithm.MinimumDiameter.getMinimumRectangle(polygon);
console.log('MinimumDiameter.getMinimumRectangle (minimum WIDTH):');
console.log('  Type:', minDiamRect.type);
if (minDiamRect.type === 'Polygon') {
    console.log('  Area:', minDiamRect.getArea().toFixed(2));
}
console.log('');

// Find minimum-area bounding rectangle (rotating calipers algorithm)
const minAreaRect = wasmts.algorithm.MinimumAreaRectangle.getMinimumRectangle(polygon);
console.log('MinimumAreaRectangle.getMinimumRectangle (minimum AREA):');
console.log('  Type:', minAreaRect.type);
if (minAreaRect.type === 'Polygon') {
    console.log('  Area:', minAreaRect.getArea().toFixed(2));
    console.log('  Contains original:', minAreaRect.contains(polygon));
}
console.log('');

// Compare rectangle algorithms
console.log('Rectangle Comparison:');
console.log('  Original polygon area:', polygon.getArea().toFixed(2));
if (minDiamRect.type === 'Polygon' && minAreaRect.type === 'Polygon') {
    console.log('  Min-width rect area:', minDiamRect.getArea().toFixed(2));
    console.log('  Min-area rect area:', minAreaRect.getArea().toFixed(2));
}
console.log('');

// MinimumBoundingCircle - smallest enclosing circle
console.log('MinimumBoundingCircle:');
const circle = wasmts.algorithm.MinimumBoundingCircle.getCircle(polygon);
console.log('  Circle type:', circle.type);
console.log('  Circle area:', circle.getArea().toFixed(2));

const centre = wasmts.algorithm.MinimumBoundingCircle.getCentre(polygon);
console.log('  Centre:', centre.x.toFixed(2), centre.y.toFixed(2));

const radius = wasmts.algorithm.MinimumBoundingCircle.getRadius(polygon);
console.log('  Radius:', radius.toFixed(2));
console.log('  Expected area (pi*r^2):', (Math.PI * radius * radius).toFixed(2));

// Test with a triangle
const triangle = wasmts.io.WKTReader.read('POLYGON ((0 0, 10 0, 5 10, 0 0))');
const triRect = wasmts.algorithm.MinimumAreaRectangle.getMinimumRectangle(triangle);
console.log('\\nTriangle minimum rectangle area:', triRect.getArea().toFixed(2));

minAreaRect`,

            offsetcurve: `// Offset Curves
// Create parallel lines/curves for road shoulders, railroad tracks, etc.
// Useful for road shoulders, railroad tracks, buffer boundaries, etc.

// Create a simple line
const line = wasmts.io.WKTReader.read('LINESTRING (0 0, 10 0, 10 10)');
console.log('Created test line\\n');

// Standard offset to the right (positive distance)
const rightOffset = wasmts.operation.buffer.OffsetCurveBuilder.getOffsetCurve(line, 2);
console.log('Right offset points:', rightOffset.getCoordinates().length);

// Offset to the left (negative distance)
const leftOffset = wasmts.operation.buffer.OffsetCurveBuilder.getOffsetCurve(line, -2);
console.log('Left offset points:', leftOffset.getCoordinates().length);
console.log('');

// Custom parameters for different corner styles
const CAP_FLAT = 2, JOIN_MITRE = 2;
const sharpOffset = wasmts.operation.buffer.OffsetCurveBuilder.getOffsetCurve(line, 2, CAP_FLAT, JOIN_MITRE, 10.0);
console.log('Sharp corner offset created');
console.log('');

// Offset curves on polygons (creates offset of exterior ring)
const poly = wasmts.io.WKTReader.read('POLYGON ((0 0, 20 0, 20 20, 0 20, 0 0))');
const polyOffset = wasmts.operation.buffer.OffsetCurveBuilder.getOffsetCurve(poly, 3);
console.log('Polygon exterior offset created');
console.log('Offset points:', polyOffset.getCoordinates().length);
console.log('');

// Compare with buffer (offset curve is just the line, buffer is filled area)
const buffer = line.buffer(2);
console.log('Buffer area:', buffer.getArea().toFixed(2));
console.log('Offset curve is just the boundary line');

rightOffset`,

            linemerger: `// LineMerger - Combine connected linestrings into longer lines
// Useful for simplifying road networks, contours, etc.

// Create separate line segments that connect end-to-end
const line1 = wasmts.io.WKTReader.read('LINESTRING (0 0, 5 0)');
const line2 = wasmts.io.WKTReader.read('LINESTRING (5 0, 10 0)');
const line3 = wasmts.io.WKTReader.read('LINESTRING (10 0, 10 5)');

// Separate disconnected line
const line4 = wasmts.io.WKTReader.read('LINESTRING (20 20, 25 25)');

console.log('Created 4 separate line segments\\n');

// Create LineMerger instance
const merger = wasmts.operation.linemerge.LineMerger.create();

// Add all lines to the merger
wasmts.operation.linemerge.LineMerger.add(merger, line1);
wasmts.operation.linemerge.LineMerger.add(merger, line2);
wasmts.operation.linemerge.LineMerger.add(merger, line3);
wasmts.operation.linemerge.LineMerger.add(merger, line4);
console.log('Added 4 lines to merger\\n');

// Get merged result
const merged = wasmts.operation.linemerge.LineMerger.getMergedLineStrings(merger);
console.log('Merged result count:', merged.length);
console.log('(Connected lines merged into 1, disconnected line stays separate)\\n');

// Examine the merged lines
merged.forEach((line, i) => {
    const coords = line.getCoordinates();
    console.log(\`Line \${i + 1}: \${coords.length} points\`);
    console.log('  Start:', coords[0].x, coords[0].y);
    console.log('  End:', coords[coords.length - 1].x, coords[coords.length - 1].y);
});

merged[0]`,

            cascadedunion: `// CascadedPolygonUnion - Efficiently union many overlapping polygons
// Much faster than iteratively unioning polygons one-by-one

// Create multiple overlapping polygons
const poly1 = wasmts.io.WKTReader.read('POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))');
const poly2 = wasmts.io.WKTReader.read('POLYGON ((5 5, 15 5, 15 15, 5 15, 5 5))');
const poly3 = wasmts.io.WKTReader.read('POLYGON ((10 10, 20 10, 20 20, 10 20, 10 10))');
const poly4 = wasmts.io.WKTReader.read('POLYGON ((8 0, 18 0, 18 8, 8 8, 8 0))');

console.log('Created 4 overlapping polygons');
console.log('Total area (with overlaps):',
    poly1.getArea() + poly2.getArea() + poly3.getArea() + poly4.getArea());
console.log('');

// Union all at once (much faster than sequential unions)
const union = wasmts.operation.union.CascadedPolygonUnion.union([poly1, poly2, poly3, poly4]);

console.log('Union result type:', union.type);
console.log('Union area (overlaps removed):', union.getArea().toFixed(2));
console.log('Area saved by removing overlaps:',
    ((poly1.getArea() + poly2.getArea() + poly3.getArea() + poly4.getArea()) - union.getArea()).toFixed(2));

union`,

            "3d": `// 3D Geometries with Z coordinates

// Create 3D point
const point3d = wasmts.geom.createPoint(5, 10, 15);
console.log('3D Point created');
const coords = point3d.getCoordinates();
console.log('X:', coords[0].x, 'Y:', coords[0].y, 'Z:', coords[0].z);

// Create 3D LineString with elevation
const line3d = wasmts.io.WKTReader.read('LINESTRING Z (0 0 0, 1 1 10, 2 1 20, 3 0 15)');
console.log('\\n3D LineString created');
const lineCoords = line3d.getCoordinates();
console.log('Points:', lineCoords.length);
lineCoords.forEach((c, i) => {
    console.log(\`  Point \${i}: X=\${c.x}, Y=\${c.y}, Z=\${c.z}\`);
});

// Calculate 2D length (ignores Z)
console.log('\\n2D length:', line3d.getLength().toFixed(2));

// WKT/WKB I/O preserves Z
const wkt = wasmts.io.WKTWriter.write(point3d);
console.log('\\nWKT:', wkt);

const wkb = wasmts.io.WKBWriter.write(line3d);
console.log('WKB size:', wkb.length, 'bytes');

const fromWKB = wasmts.io.WKBReader.read(wkb);
const wkbCoords = fromWKB.getCoordinates();
console.log('Round-trip Z preserved:', wkbCoords[2].z === 20);

line3d`,

            "4d": `// 4D Geometries with XYZM coordinates (Z=elevation, M=measure)

// Create 4D point
const point4d = wasmts.geom.createPoint(5, 10, 15, 20);
console.log('4D Point (XYZM) created');
const coords = point4d.getCoordinates();
console.log('X:', coords[0].x, 'Y:', coords[0].y, 'Z:', coords[0].z, 'M:', coords[0].m);

// Create 4D LineString (with measure values for linear referencing)
const line4d = wasmts.io.WKTReader.read('LINESTRING ZM (0 0 0 100, 1 1 10 200, 2 0 20 300)');
console.log('\\n4D LineString created');
const line4dCoords = line4d.getCoordinates();
console.log('Point 0:', line4dCoords[0]);
console.log('Point 1:', line4dCoords[1]);

// WKB round-trip preserves Z and M
const wkb = wasmts.io.WKBWriter.write(line4d);
console.log('\\nWKB size:', wkb.length, 'bytes');
const parsed = wasmts.io.WKBReader.read(wkb);
const parsedCoords = parsed.getCoordinates();
console.log('Round-trip M preserved:', parsedCoords[1].m === 200);

point4d`,

            io: `// WKT and WKB Input/Output

console.log('=== WKT I/O ===');

// Read from WKT
const poly = wasmts.io.WKTReader.read('POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))');
console.log('Read polygon, area:', poly.getArea());

// Write to WKT
const wkt = wasmts.io.WKTWriter.write(poly);
console.log('WKT:', wkt);

console.log('\\n=== WKB I/O ===');

// Write to WKB (binary format)
const wkb = wasmts.io.WKBWriter.write(poly);
console.log('WKB size:', wkb.length, 'bytes');
console.log('First 10 bytes:', Array.from(wkb.slice(0, 10)));

// Read from WKB
const fromWKB = wasmts.io.WKBReader.read(wkb);
console.log('Round-trip successful:', fromWKB.equals(poly));

console.log('\\n=== 3D/4D I/O ===');

// 3D geometries
const point3d = wasmts.geom.createPoint(1, 2, 3);
const wkt3d = wasmts.io.WKTWriter.write(point3d);
console.log('3D WKT:', wkt3d);

// 4D geometries
const line4d = wasmts.io.WKTReader.read('LINESTRING ZM (0 0 0 100, 1 1 10 200)');
const wkb4d = wasmts.io.WKBWriter.write(line4d);
console.log('4D WKB size:', wkb4d.length, 'bytes');

poly`,

            geojson: `// GeoJSON Input/Output
// Read and write GeoJSON format - the standard for web mapping

console.log('=== GeoJSON Reader ===');

// Read a Point from GeoJSON
const pointGeoJSON = '{"type":"Point","coordinates":[5,10]}';
const point = wasmts.io.GeoJSONReader.read(pointGeoJSON);
console.log('Point type:', point.type);
console.log('Coordinates:', point.getCoordinates()[0]);

// Read a Polygon from GeoJSON
const polyGeoJSON = '{"type":"Polygon","coordinates":[[[0,0],[10,0],[10,10],[0,10],[0,0]]]}';
const poly = wasmts.io.GeoJSONReader.read(polyGeoJSON);
console.log('\\nPolygon area:', poly.getArea());

// Read a Polygon with a hole
const holeGeoJSON = '{"type":"Polygon","coordinates":[[[0,0],[20,0],[20,20],[0,20],[0,0]],[[5,5],[15,5],[15,15],[5,15],[5,5]]]}';
const polyWithHole = wasmts.io.GeoJSONReader.read(holeGeoJSON);
console.log('Polygon with hole area:', polyWithHole.getArea(), '(400 - 100 = 300)');

console.log('\\n=== GeoJSON Writer ===');

// Write geometry to GeoJSON
const circle = wasmts.geom.createPoint(0, 0).buffer(10);
const circleGeoJSON = wasmts.io.GeoJSONWriter.write(circle);
const parsed = JSON.parse(circleGeoJSON);
console.log('Buffer type:', parsed.type);
console.log('Buffer vertices:', parsed.coordinates[0].length);

// Round-trip test
const line = wasmts.io.WKTReader.read('LINESTRING (0 0, 10 10, 20 0)');
const lineGeoJSON = wasmts.io.GeoJSONWriter.write(line);
console.log('\\nLineString GeoJSON:', lineGeoJSON);

console.log('\\n=== Format Conversion ===');

// GeoJSON to WKT
const geoJsonInput = '{"type":"Polygon","coordinates":[[[0,0],[100,0],[100,50],[0,50],[0,0]]]}';
const fromGeoJson = wasmts.io.GeoJSONReader.read(geoJsonInput);
const asWkt = wasmts.io.WKTWriter.write(fromGeoJson);
console.log('GeoJSON -> WKT:', asWkt);

// WKT to GeoJSON
const wktInput = 'MULTIPOINT ((10 20), (30 40), (50 60))';
const fromWkt = wasmts.io.WKTReader.read(wktInput);
const asGeoJson = wasmts.io.GeoJSONWriter.write(fromWkt);
console.log('WKT -> GeoJSON:', asGeoJson);

console.log('\\n=== 3D GeoJSON ===');

// 3D coordinates are preserved
const point3d = wasmts.io.GeoJSONReader.read('{"type":"Point","coordinates":[5,10,15]}');
const coords3d = point3d.getCoordinates()[0];
console.log('3D Point: x=' + coords3d.x + ', y=' + coords3d.y + ', z=' + coords3d.z);

// Write 3D back to GeoJSON
const out3d = wasmts.io.GeoJSONWriter.write(point3d);
console.log('3D GeoJSON:', out3d);

console.log('\\n=== Multi Geometries ===');

// MultiPolygon
const multiPoly = wasmts.io.GeoJSONReader.read('{"type":"MultiPolygon","coordinates":[[[[0,0],[10,0],[10,10],[0,10],[0,0]]],[[[20,20],[30,20],[30,30],[20,30],[20,20]]]]}');
console.log('MultiPolygon area:', multiPoly.getArea());

// GeometryCollection
const gc = wasmts.io.GeoJSONReader.read('{"type":"GeometryCollection","geometries":[{"type":"Point","coordinates":[0,0]},{"type":"LineString","coordinates":[[0,0],[10,10]]}]}');
console.log('GeometryCollection type:', gc.type);

poly`,

            polyaccessors: `// Polygon Accessors - Access Exterior Ring and Interior Holes
// Essential for parcel analysis, area calculations, and geometry manipulation

console.log('=== Simple Polygon (No Holes) ===');

// Create a simple polygon without holes
const simplePoly = wasmts.io.WKTReader.read('POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))');
console.log('Simple polygon area:', simplePoly.getArea());

// Get the exterior ring (outer boundary)
const exteriorRing = simplePoly.getExteriorRing();
console.log('Exterior ring type:', exteriorRing.type);
console.log('Exterior ring coordinates:', exteriorRing.getCoordinates().length, 'points');

// Check for interior rings (holes)
const numHoles = simplePoly.getNumInteriorRing();
console.log('Number of holes:', numHoles);

console.log('\\n=== Polygon with One Hole ===');

// Create a polygon with a hole (donut shape)
const polyWithHole = wasmts.io.WKTReader.read(
    'POLYGON ((0 0, 20 0, 20 20, 0 20, 0 0), (5 5, 15 5, 15 15, 5 15, 5 5))'
);
console.log('Polygon with hole area:', polyWithHole.getArea(), '(400 - 100 = 300)');
console.log('Number of holes:', polyWithHole.getNumInteriorRing());

// Access the interior ring (hole)
const hole = polyWithHole.getInteriorRingN(0);
console.log('Hole ring type:', hole.type);
console.log('Hole coordinates:', hole.getCoordinates().length, 'points');

// Get hole start coordinates
const holeCoords = hole.getCoordinates();
console.log('Hole start point:', holeCoords[0].x, holeCoords[0].y);

console.log('\\n=== Polygon with Multiple Holes ===');

// Create a polygon with multiple holes
const multiHolePoly = wasmts.io.WKTReader.read(
    'POLYGON ((0 0, 30 0, 30 30, 0 30, 0 0), ' +
    '(2 2, 8 2, 8 8, 2 8, 2 2), ' +
    '(12 12, 18 12, 18 18, 12 18, 12 12), ' +
    '(22 2, 28 2, 28 8, 22 8, 22 2))'
);
console.log('Multi-hole polygon area:', multiHolePoly.getArea());
console.log('Number of holes:', multiHolePoly.getNumInteriorRing());

// Iterate through all holes
console.log('\\nHole details:');
for (let i = 0; i < multiHolePoly.getNumInteriorRing(); i++) {
    const ring = multiHolePoly.getInteriorRingN(i);
    const coords = ring.getCoordinates();
    console.log(\`  Hole \${i}: starts at (\${coords[0].x}, \${coords[0].y})\`);
}

console.log('\\n=== Practical Use: Calculate Total Hole Area ===');

// Calculate the area of all holes
let totalHoleArea = 0;
const outerRing = multiHolePoly.getExteriorRing();

// Create polygon from each hole ring to get its area
for (let i = 0; i < multiHolePoly.getNumInteriorRing(); i++) {
    const holeRing = multiHolePoly.getInteriorRingN(i);
    // Convert ring coordinates to WKT to create a polygon
    const holeCoords = holeRing.getCoordinates();
    const wkt = 'POLYGON ((' + holeCoords.map(c => c.x + ' ' + c.y).join(', ') + '))';
    const holePoly = wasmts.io.WKTReader.read(wkt);
    totalHoleArea += holePoly.getArea();
}

console.log('Outer boundary area:', 900, '(30x30)');
console.log('Total hole area:', totalHoleArea);
console.log('Net polygon area:', multiHolePoly.getArea());

polyWithHole`,

            distance: `// Distance Operations - Find nearest points between geometries
// Useful for finding closest features, connection points, etc.

console.log('=== Basic Distance ===');

// Create two separate polygons
const poly1 = wasmts.io.WKTReader.read('POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))');
const poly2 = wasmts.io.WKTReader.read('POLYGON ((20 0, 30 0, 30 10, 20 10, 20 0))');

// Simple distance calculation
const dist = poly1.distance(poly2);
console.log('Distance between polygons:', dist);

console.log('\\n=== Nearest Points ===');

// Get the actual closest points on each geometry
const nearest = wasmts.geom.nearestPoints(poly1, poly2);
console.log('Nearest point on poly1:', nearest[0]);
console.log('Nearest point on poly2:', nearest[1]);

// Verify the distance matches
const calcDist = Math.sqrt(
    Math.pow(nearest[1].x - nearest[0].x, 2) +
    Math.pow(nearest[1].y - nearest[0].y, 2)
);
console.log('Calculated distance from points:', calcDist.toFixed(2));

console.log('\\n=== Point to Line ===');

// Find nearest point on a line from a point
const point = wasmts.geom.createPoint(5, 5);
const line = wasmts.io.WKTReader.read('LINESTRING (0 0, 10 0)');

const nearestPtLine = wasmts.geom.nearestPoints(point, line);
console.log('Point:', nearestPtLine[0]);
console.log('Closest point on line:', nearestPtLine[1]);
console.log('Distance:', point.distance(line).toFixed(2));

console.log('\\n=== Practical Use: Connect Two Features ===');

// Create a line connecting the two nearest points
const connectorWKT = \`LINESTRING (\${nearest[0].x} \${nearest[0].y}, \${nearest[1].x} \${nearest[1].y})\`;
const connector = wasmts.io.WKTReader.read(connectorWKT);
console.log('Connector line:', wasmts.io.WKTWriter.write(connector));
console.log('Connector length:', connector.getLength().toFixed(2));

nearest`,

            factory: `// Geometry Factory - Create geometries from coordinate arrays
// Alternative to WKT/WKB when building geometries programmatically

console.log('=== createPoint ===');

// 2D point
const point2D = wasmts.geom.createPoint(5, 10);
console.log('2D Point:', point2D.getCoordinates()[0]);

// 3D point (with Z)
const point3D = wasmts.geom.createPoint(5, 10, 15);
console.log('3D Point:', point3D.getCoordinates()[0]);

// 4D point (with Z and M)
const point4D = wasmts.geom.createPoint(5, 10, 15, 20);
console.log('4D Point:', point4D.getCoordinates()[0]);

console.log('\\n=== createLineString ===');

// Create a LineString from coordinate objects
const lineCoords = [
    { x: 0, y: 0 },
    { x: 10, y: 10 },
    { x: 20, y: 0 }
];
const line = wasmts.geom.createLineString(lineCoords);
console.log('LineString created, points:', line.getNumPoints());
console.log('Length:', line.getLength().toFixed(2));

// With 3D coordinates
const line3D = wasmts.geom.createLineString([
    { x: 0, y: 0, z: 0 },
    { x: 10, y: 10, z: 5 },
    { x: 20, y: 0, z: 10 }
]);
const coords3D = line3D.getCoordinates();
console.log('3D LineString Z values:', coords3D.map(c => c.z).join(', '));

console.log('\\n=== createPolygon (simple) ===');

// Create a simple polygon (no holes)
const shell = [
    { x: 0, y: 0 },
    { x: 100, y: 0 },
    { x: 100, y: 100 },
    { x: 0, y: 100 },
    { x: 0, y: 0 }  // Close the ring
];
const polygon = wasmts.geom.createPolygon(shell);
console.log('Polygon created, area:', polygon.getArea());
console.log('Is valid:', polygon.isValid());

console.log('\\n=== createPolygon (with hole) ===');

// Create a polygon with a hole (donut shape)
const hole = [
    { x: 25, y: 25 },
    { x: 75, y: 25 },
    { x: 75, y: 75 },
    { x: 25, y: 75 },
    { x: 25, y: 25 }  // Close the hole
];
const donut = wasmts.geom.createPolygon(shell, [hole]);
console.log('Donut area:', donut.getArea(), '(10000 - 2500 = 7500)');
console.log('Number of holes:', donut.getNumInteriorRing());

console.log('\\n=== createPolygon (multiple holes) ===');

// Create a polygon with multiple holes
const hole1 = [
    { x: 10, y: 10 },
    { x: 30, y: 10 },
    { x: 30, y: 30 },
    { x: 10, y: 30 },
    { x: 10, y: 10 }
];
const hole2 = [
    { x: 60, y: 60 },
    { x: 90, y: 60 },
    { x: 90, y: 90 },
    { x: 60, y: 90 },
    { x: 60, y: 60 }
];
const multiHole = wasmts.geom.createPolygon(shell, [hole1, hole2]);
console.log('Multi-hole polygon area:', multiHole.getArea());
console.log('Number of holes:', multiHole.getNumInteriorRing());

console.log('\\n=== Practical: Build from nearestPoints ===');

// Use with other API results
const poly1 = wasmts.io.WKTReader.read('POLYGON ((0 0, 10 0, 10 10, 0 10, 0 0))');
const poly2 = wasmts.io.WKTReader.read('POLYGON ((20 0, 30 0, 30 10, 20 10, 20 0))');

// Get nearest points and create a connector line
const nearest = wasmts.geom.nearestPoints(poly1, poly2);
const connector = wasmts.geom.createLineString([nearest[0], nearest[1]]);
console.log('Connector line length:', connector.getLength());

console.log('\\n=== 3D Polygon ===');

// Create 3D polygon (all Z same for a flat plane)
const shell3D = [
    { x: 0, y: 0, z: 10 },
    { x: 10, y: 0, z: 10 },
    { x: 10, y: 10, z: 10 },
    { x: 0, y: 10, z: 10 },
    { x: 0, y: 0, z: 10 }
];
const poly3D = wasmts.geom.createPolygon(shell3D);
console.log('3D polygon Z:', poly3D.getCoordinates()[0].z);

polygon`
        };

        // Dropdown handler
        document.getElementById('exampleSelect').addEventListener('change', (e) => {
            if (!monacoEditor) return;
            const exampleKey = e.target.value;
            if (!exampleKey || !examples[exampleKey]) return;

            document.getElementById('replClear').click();
            monacoEditor.setValue(examples[exampleKey]);
            monacoEditor.focus();

            // Reset dropdown to placeholder
            setTimeout(() => {
                e.target.value = '';
            }, 100);
        });

        // REPL functionality
        const replOutput = document.getElementById('replOutput');

        function replLog(text, type = 'output') {
            const line = document.createElement('div');
            line.className = `repl-line repl-${type}`;
            line.textContent = text;
            replOutput.appendChild(line);
            replOutput.scrollTop = replOutput.scrollHeight;
        }

        function formatValue(value) {
            if (value === undefined) return undefined;
            if (typeof value === 'object' && value !== null) {
                // Pretty print objects
                if (value.type && value._jtsGeom) {
                    // It's a geometry object - show appropriate metrics based on type
                    const type = value.type;
                    const metrics = [];

                    // Polygonal types: show area
                    if (type === 'Polygon' || type === 'MultiPolygon' || type === 'GeometryCollection') {
                        const area = value.getArea?.();
                        if (area !== undefined && area > 0) {
                            metrics.push(`area: ${area.toFixed(2)}`);
                        }
                    }

                    // Linear types: show length
                    if (type === 'LineString' || type === 'MultiLineString' || type === 'LinearRing') {
                        const length = value.getLength?.();
                        if (length !== undefined && length > 0) {
                            metrics.push(`length: ${length.toFixed(2)}`);
                        }
                    }

                    // Points: show coordinates count
                    if (type === 'Point' || type === 'MultiPoint') {
                        const coords = value.getCoordinates?.();
                        if (coords && coords.length > 0) {
                            const coord = coords[0];
                            const dims = coord.m !== undefined ? '4D' : coord.z !== undefined ? '3D' : '2D';
                            metrics.push(`${dims}`);
                        }
                    }

                    metrics.push(`valid: ${value.isValid?.()}`);
                    return `${type} { ${metrics.join(', ')} }`;
                } else if (value instanceof Uint8Array) {
                    // Format byte array as hex string
                    const hex = Array.from(value.slice(0, 32))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join(' ');
                    return `Uint8Array(${value.length}) [ ${hex}${value.length > 32 ? ' ...' : ''} ]`;
                } else if (Array.isArray(value)) {
                    return `Array(${value.length}) [ ${value.slice(0, 5).map(r => JSON.stringify(r)).join(', ')}${value.length > 5 ? '...' : ''} ]`;
                } else {
                    return JSON.stringify(value, null, 2);
                }
            }
            return String(value);
        }

        function runREPL() {
            if (!monacoEditor) return;
            const code = monacoEditor.getValue().trim();
            if (!code) return;

            // Show input
            replLog('> ' + code.split('\n').join('\n  '), 'input');

            try {
                // Intercept console.log
                const logs = [];
                const originalLog = console.log;
                console.log = function(...args) {
                    logs.push(args.map(arg => formatValue(arg) || String(arg)).join(' '));
                    originalLog.apply(console, args);
                };

                // Evaluate all code as one block
                const result = eval(code);

                // Restore console.log
                console.log = originalLog;

                // Show console.log output
                logs.forEach(log => replLog(log, 'output'));

                // Display final result
                if (result !== undefined) {
                    const formatted = formatValue(result);
                    if (formatted) {
                        replLog(formatted, 'output');
                    }
                }
            } catch (err) {
                replLog(`Error: ${err.message}`, 'error');
                console.error(err);
            }

            replLog('', 'output'); // Empty line for spacing
        }

        document.getElementById('replRun').addEventListener('click', runREPL);

        document.getElementById('replClear').addEventListener('click', () => {
            replOutput.innerHTML = '<div class="repl-hint">// Output cleared. Ready for new commands.</div>';
        });

        // Initialize REPL output
        document.getElementById('replClear').click();
    </script>
</body>
</html>
